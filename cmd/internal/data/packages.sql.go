// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: packages.sql

package data

import (
	"context"
	"database/sql"
	"strings"
)

const addPackageWithVersion = `-- name: AddPackageWithVersion :one
INSERT INTO packages (name, url, version) 
VALUES (?, ?, ?)
ON CONFLICT (name) DO UPDATE 
SET is_deleted = false, url = excluded.url, version = excluded.version
RETURNING id, name, url, version, freq, created_at, updated_at, last_used, is_deleted
`

type AddPackageWithVersionParams struct {
	Name    string
	Url     string
	Version sql.NullString
}

func (q *Queries) AddPackageWithVersion(ctx context.Context, arg AddPackageWithVersionParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, addPackageWithVersion, arg.Name, arg.Url, arg.Version)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Version,
		&i.Freq,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsed,
		&i.IsDeleted,
	)
	return i, err
}

const cleanDatabase = `-- name: CleanDatabase :exec
DELETE from packages
where is_deleted = true
`

func (q *Queries) CleanDatabase(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanDatabase)
	return err
}

const deletePackagesByName = `-- name: DeletePackagesByName :exec
DELETE FROM packages
WHERE name IN (/*SLICE:names*/?)
`

func (q *Queries) DeletePackagesByName(ctx context.Context, names []string) error {
	query := deletePackagesByName
	var queryParams []interface{}
	if len(names) > 0 {
		for _, v := range names {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:names*/?", strings.Repeat(",?", len(names))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:names*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const getIDByName = `-- name: GetIDByName :one
SELECT id FROM packages WHERE name = ?
`

func (q *Queries) GetIDByName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getIDByName, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getPackageByID = `-- name: GetPackageByID :one
SELECT id, name, url, version, freq, created_at, updated_at, last_used, is_deleted FROM packages WHERE id = ? and is_deleted = false
`

func (q *Queries) GetPackageByID(ctx context.Context, id int64) (Package, error) {
	row := q.db.QueryRowContext(ctx, getPackageByID, id)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Version,
		&i.Freq,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsed,
		&i.IsDeleted,
	)
	return i, err
}

const getPackageByName = `-- name: GetPackageByName :one
SELECT id, name, url, version, freq, created_at, updated_at, last_used, is_deleted FROM packages WHERE name =? and is_deleted = false
`

func (q *Queries) GetPackageByName(ctx context.Context, name string) (Package, error) {
	row := q.db.QueryRowContext(ctx, getPackageByName, name)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Version,
		&i.Freq,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsed,
		&i.IsDeleted,
	)
	return i, err
}

const getPackageIDByURL = `-- name: GetPackageIDByURL :one
SELECT id
FROM packages
WHERE url = ?
`

func (q *Queries) GetPackageIDByURL(ctx context.Context, url string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPackageIDByURL, url)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getURLsByNames = `-- name: GetURLsByNames :many
SELECT name, url, version 
FROM packages 
WHERE name IN (/*SLICE:names*/?)
`

type GetURLsByNamesRow struct {
	Name    string
	Url     string
	Version sql.NullString
}

func (q *Queries) GetURLsByNames(ctx context.Context, names []string) ([]GetURLsByNamesRow, error) {
	query := getURLsByNames
	var queryParams []interface{}
	if len(names) > 0 {
		for _, v := range names {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:names*/?", strings.Repeat(",?", len(names))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:names*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetURLsByNamesRow
	for rows.Next() {
		var i GetURLsByNamesRow
		if err := rows.Scan(&i.Name, &i.Url, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackagesByFrequency = `-- name: ListPackagesByFrequency :many
SELECT id, name, url, version, freq, created_at, updated_at, last_used, is_deleted FROM packages
WHERE is_deleted = false
ORDER BY freq DESC
LIMIT ?
`

func (q *Queries) ListPackagesByFrequency(ctx context.Context, limit int64) ([]Package, error) {
	rows, err := q.db.QueryContext(ctx, listPackagesByFrequency, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Version,
			&i.Freq,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsed,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackagesByLastUsed = `-- name: ListPackagesByLastUsed :many
SELECT id, name, url, version, freq, created_at, updated_at, last_used, is_deleted FROM packages
WHERE is_deleted = false
ORDER BY last_used DESC
LIMIT ?
`

func (q *Queries) ListPackagesByLastUsed(ctx context.Context, limit int64) ([]Package, error) {
	rows, err := q.db.QueryContext(ctx, listPackagesByLastUsed, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Version,
			&i.Freq,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsed,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDeleteByName = `-- name: MarkDeleteByName :exec
UPDATE packages
SET is_deleted = true, updated_at = CURRENT_TIMESTAMP
WHERE name IN (/*SLICE:names*/?)
`

func (q *Queries) MarkDeleteByName(ctx context.Context, names []string) error {
	query := markDeleteByName
	var queryParams []interface{}
	if len(names) > 0 {
		for _, v := range names {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:names*/?", strings.Repeat(",?", len(names))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:names*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const markDeleteFalse = `-- name: MarkDeleteFalse :exec
UPDATE packages
set is_deleted = false, updated_at = CURRENT_TIMESTAMP
where name in (/*SLICE:names*/?)
`

func (q *Queries) MarkDeleteFalse(ctx context.Context, names []string) error {
	query := markDeleteFalse
	var queryParams []interface{}
	if len(names) > 0 {
		for _, v := range names {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:names*/?", strings.Repeat(",?", len(names))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:names*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const updatePackage = `-- name: UpdatePackage :one
UPDATE packages
SET name = ?, url = ?, version = ?
WHERE id = ?
RETURNING id, name, url, version, freq, created_at, updated_at, last_used, is_deleted
`

type UpdatePackageParams struct {
	Name    string
	Url     string
	Version sql.NullString
	ID      int64
}

func (q *Queries) UpdatePackage(ctx context.Context, arg UpdatePackageParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, updatePackage,
		arg.Name,
		arg.Url,
		arg.Version,
		arg.ID,
	)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Version,
		&i.Freq,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsed,
		&i.IsDeleted,
	)
	return i, err
}

const updatePackageByName = `-- name: UpdatePackageByName :one
UPDATE packages
SET url = ?, version = ?
WHERE name = ?
RETURNING id, name, url, version, freq, created_at, updated_at, last_used, is_deleted
`

type UpdatePackageByNameParams struct {
	Url     string
	Version sql.NullString
	Name    string
}

func (q *Queries) UpdatePackageByName(ctx context.Context, arg UpdatePackageByNameParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, updatePackageByName, arg.Url, arg.Version, arg.Name)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Version,
		&i.Freq,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsed,
		&i.IsDeleted,
	)
	return i, err
}

const updatePackageUsage = `-- name: UpdatePackageUsage :exec
UPDATE packages 
SET freq = freq + 1, last_used = CURRENT_TIMESTAMP 
WHERE url = ?
`

func (q *Queries) UpdatePackageUsage(ctx context.Context, url string) error {
	_, err := q.db.ExecContext(ctx, updatePackageUsage, url)
	return err
}

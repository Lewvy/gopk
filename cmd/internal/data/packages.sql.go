// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: packages.sql

package data

import (
	"context"
	"database/sql"
	"strings"
)

const addPackageWithVersion = `-- name: AddPackageWithVersion :one
INSERT into packages (name, url, version) VALUES (
	?, ?, ?
	) RETURNING id, name, url, version, freq, created_at, updated_at, last_used
`

type AddPackageWithVersionParams struct {
	Name    string
	Url     string
	Version sql.NullString
}

func (q *Queries) AddPackageWithVersion(ctx context.Context, arg AddPackageWithVersionParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, addPackageWithVersion, arg.Name, arg.Url, arg.Version)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Version,
		&i.Freq,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsed,
	)
	return i, err
}

const getIDByName = `-- name: GetIDByName :one
select id from packages where name = ?
`

func (q *Queries) GetIDByName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getIDByName, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getPackageByID = `-- name: GetPackageByID :one
select id, name, url, version, freq, created_at, updated_at, last_used from packages where id = ?
`

func (q *Queries) GetPackageByID(ctx context.Context, id int64) (Package, error) {
	row := q.db.QueryRowContext(ctx, getPackageByID, id)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Version,
		&i.Freq,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsed,
	)
	return i, err
}

const getPackageByName = `-- name: GetPackageByName :one
select id, name, url, version, freq, created_at, updated_at, last_used from packages where name = ?
`

func (q *Queries) GetPackageByName(ctx context.Context, name string) (Package, error) {
	row := q.db.QueryRowContext(ctx, getPackageByName, name)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Version,
		&i.Freq,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsed,
	)
	return i, err
}

const getURLsByNames = `-- name: GetURLsByNames :many
SELECT name, url, version 
FROM packages 
WHERE name IN (/*SLICE:names*/?)
`

type GetURLsByNamesRow struct {
	Name    string
	Url     string
	Version sql.NullString
}

func (q *Queries) GetURLsByNames(ctx context.Context, names []string) ([]GetURLsByNamesRow, error) {
	query := getURLsByNames
	var queryParams []interface{}
	if len(names) > 0 {
		for _, v := range names {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:names*/?", strings.Repeat(",?", len(names))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:names*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetURLsByNamesRow
	for rows.Next() {
		var i GetURLsByNamesRow
		if err := rows.Scan(&i.Name, &i.Url, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackagesByFrequency = `-- name: ListPackagesByFrequency :many
SELECT id, name, url, version, freq, created_at, updated_at, last_used FROM packages
ORDER BY freq DESC
LIMIT ?
`

func (q *Queries) ListPackagesByFrequency(ctx context.Context, limit int64) ([]Package, error) {
	rows, err := q.db.QueryContext(ctx, listPackagesByFrequency, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Version,
			&i.Freq,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackagesByLastUsed = `-- name: ListPackagesByLastUsed :many
SELECT id, name, url, version, freq, created_at, updated_at, last_used FROM packages
ORDER BY last_used DESC
LIMIT ?
`

func (q *Queries) ListPackagesByLastUsed(ctx context.Context, limit int64) ([]Package, error) {
	rows, err := q.db.QueryContext(ctx, listPackagesByLastUsed, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Version,
			&i.Freq,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePackage = `-- name: UpdatePackage :one
UPDATE packages
set name = ?, url = ?, version = ?
where id = ?
RETURNING id, name, url, version, freq, created_at, updated_at, last_used
`

type UpdatePackageParams struct {
	Name    string
	Url     string
	Version sql.NullString
	ID      int64
}

func (q *Queries) UpdatePackage(ctx context.Context, arg UpdatePackageParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, updatePackage,
		arg.Name,
		arg.Url,
		arg.Version,
		arg.ID,
	)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Version,
		&i.Freq,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsed,
	)
	return i, err
}

const updatePackageByName = `-- name: UpdatePackageByName :one
UPDATE packages
set url = ?, version = ?
where name = ?
RETURNING id, name, url, version, freq, created_at, updated_at, last_used
`

type UpdatePackageByNameParams struct {
	Url     string
	Version sql.NullString
	Name    string
}

func (q *Queries) UpdatePackageByName(ctx context.Context, arg UpdatePackageByNameParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, updatePackageByName, arg.Url, arg.Version, arg.Name)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Version,
		&i.Freq,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsed,
	)
	return i, err
}

const updatePackageUsage = `-- name: UpdatePackageUsage :exec
UPDATE packages 
SET freq = freq + 1, last_used = CURRENT_TIMESTAMP 
WHERE url = ?
`

func (q *Queries) UpdatePackageUsage(ctx context.Context, url string) error {
	_, err := q.db.ExecContext(ctx, updatePackageUsage, url)
	return err
}
